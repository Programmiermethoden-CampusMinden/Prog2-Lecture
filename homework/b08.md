# Blatt 08: Syntax Highlighting (Reguläre Ausdrücke, Template-Method, Command)

## Zusammenfassung

Auf diesem Blatt üben Sie den Umgang mit regulären Ausdrücken in Java.
Wir nutzen diese zusammen mit dem Template-Method-Pattern für die
Implementierung eines einfachen Syntax-Highlightings.

> [!IMPORTANT]
>
> **Hinweis**: Bitte denken Sie daran, dass Sie spätestens seit Blatt 04
> die Bearbeitung der Aufgaben in Ihren öffentlich sichtbaren Git-Repos
> durchführen sollen.
>
> Erstellen Sie für **alle** Ihre Lösungen passende Pull-Requests gegen
> **Ihre eigenen Repos** (auch wenn dies nicht explizit in den Aufgaben
> gefordert wird).
>
> Die Links zu Ihren Pull-Requests mit den Lösungen geben Sie bitte
> immer in Ihrem *Post Mortem* mit an.

## Aufgaben

### Syntaxhighlighting mit RegExp

Klonen Sie die [Vorgaben “Syntax
Highlighting”](https://github.com/Programmiermethoden-CampusMinden/prog2_ybel_highlighting)
und laden Sie das Projekt als Gradle-Projekt in Ihre IDE.

Im Package `highlighting` finden Sie einige Klassen, mit denen man ein
einfaches Syntax Highlighting durchführen kann. Dazu arbeitet der Lexer
mit sogenannten “Token” (Instanzen der Klasse `Token`). Diese haben
einen regulären Ausdruck, um bestimmte Teile im Code zu erkennen,
beispielsweise Keywords oder Kommentare und anderes. Der Lexer wendet
alle Token auf den aktuellen Eingabezeichenstrom an (Methode
`Token#test()`), und die Token prüfen mit “ihrem” regulären Ausdruck, ob
die jeweils passende Eingabesequenz vorliegt. Die regulären Ausdrücke
übergeben Sie dem `Token`-Konstruktor als entsprechendes
`Pattern`-Objekt.

- Die Klasse `Token` speichert dazu ein `Pattern` (einen vorkompilierten
  regulären Ausdruck) sowie eine Farbe, die später beim Syntax
  Highlighting für dieses Token genutzt werden soll. Bei der Anwendung
  eines Tokens auf einen String (Methode `Token#test`) wird das
  gespeicherte Pattern auf den String angewendet und eine Liste aller
  passenden Stellen im String zurückgegeben (`List<Lexem>`).

  Neben dem jeweiligen Pattern kennt jedes Token noch eine
  `matchingGroup`: Dies ist ein Integer, der die relevante
  Matching-Group im regulären Ausdruck bezeichnet. Wenn Sie keine
  eigenen Gruppen in einem regulären Ausdruck eingebaut haben, nutzen
  Sie hier einfach den Wert 0.

  Zusätzlich kennt jedes Token noch die Farbe für das
  Syntax-Highlighting in der von uns als Vorgabe realisierten Swing-GUI
  (Instanz von `Color`).

- Der `Lexer` sammelt eine Liste von `Token` und wendet sie in der
  übergebenen Reihenfolge auf den Eingabestring an (Methode
  `Lexer#tokenize`).

- Die Klasse `LexerUI` dient zum Anzeigen des ursprünglichen Textes und
  des Ergebnisses. Hier sieht man recht schnell, ob die Pattern bereits
  passen … Man kann auf der linken Seite auch den Text editieren, und
  auf der rechten Seite des Fensters wird dann automatisch das Syntax
  Highlighting erneut durchgeführt.

- Die Klasse `Main` dient zum Definieren der konkreten Token (=\>
  Aufgabe) und auch zum Starten der Demo.

**Aufgabe**: Definieren Sie alle in `Main#setupTokens` genannten Token,
indem Sie jeweils einen passenden regulären Ausdruck formulieren und als
Pattern in den Konstruktor geben zusammen mit einer Farbe, mit der
dieses Token hervorgehoben werden soll:

- Strings: alles zwischen `"` und dem nächsten `"`
- Character: genau ein Zeichen zwischen `'` und `'`
- Keywords: `package`, `import`, `class`, `public`, `private`, `final`,
  `return`, `null`, `new` (jeweils freistehend, also nicht “newx” o.ä.)
- Annotation: beginnt mit `@`, enthält Buchstaben oder Minuszeichen
- Einzeiliger Kommentar: beginnend mit `//` bis zum Zeilenende
- Mehrzeiliger Kommentar: alles zwischen `/*` und dem nächsten `*/`
- Javadoc-Kommentar: alles zwischen `/**` und dem nächsten `*/`

Sie können auch mit *Matching Groups* arbeiten und im Token eine
bestimmte Gruppe hervorheben lassen. Dazu geben Sie einfach die Nummer
der Matching-Group mit in den Token-Konstruktor. (Wenn Sie nichts
übergeben, wird der gesamte Match genommen - das entspricht dem Wert 0).

Sollten Token ineinander geschachtelt sein, erkennt der Lexer dies
automatisch. Sie brauchen sich keine Gedanken dazu machen, in welcher
Reihenfolge die Token eingefügt und abgearbeitet werden. Beispiel: Im
regulären Ausdruck für den einzeiligen Kommentar brauchen Sie keine
Keywords, Annotationen, Strings usw. erkennen.

## Bearbeitung und Abgabe

- Bearbeitung: Einzelbearbeitung oder bis zu 3er Teams
- Abgabe:
  - Post Mortem [im
    ILIAS](https://www.hsbi.de/elearning/goto.php?target=exc_1514856&client_id=FH-Bielefeld)
    eintragen:

    Verfassen Sie im ILIAS pro Blatt und pro Team-Mitglied ein
    aussagekräftiges und nachvollziehbares “*Post Mortem*”. Gehen Sie
    dabei auf folgende Punkte ein:

    1.  Zusammenfassung: Was wurde gemacht?
    2.  Implementierungsdetails: Kurze Beschreibung besonders
        interessanter Aspekte der Umsetzung.
    3.  Was war der schwierigste Teil bei der Bearbeitung? Wie haben Sie
        dieses Problem gelöst?
    4.  Was haben Sie gelernt oder (besser) verstanden?
    5.  Team: Mit wem haben Sie zusammengearbeitet?
    6.  Links zu Ihren Pull-Requests mit der Lösung.

    Das Post Mortem muss von **jeder Person** im Team **individuell**
    verfasst und abgegeben werden. Der Umfang des Textes soll zwischen
    200 und 400 Wörtern liegen.

    Laden Sie hier bitte **nicht** Ihre Lösungen hoch!

  - Deadline: 27. Juni, 08:00 Uhr
- Vorstellung im Praktikum: 27. Juni

------------------------------------------------------------------------

<img src="https://licensebuttons.net/l/by-sa/4.0/88x31.png" width="10%">

Unless otherwise noted, this work is licensed under CC BY-SA 4.0.

<blockquote><p><sup><sub><strong>Last modified:</strong> c991429 (clean-up: remove dungeon from homework (#1047), 2025-09-08)<br></sub></sup></p></blockquote>
